/**
 * MockGeminiService - Mock implementation for testing
 * Provides fake code generation for development and testing
 */

import { 
  IGeminiService,
  ICodeGenerationPrompt, 
  IGeneratedCode, 
  IValidationResult, 
  ICodeIssue,
  ProgrammingLanguage,
  FileType,
  IGeneratedFile
} from '../../models/codeGeneration';

/**
 * Mock implementation of GeminiService for testing
 * Generates simple mock code based on work item information
 */
export class MockGeminiService implements IGeminiService {
  
  async generateCode(prompt: ICodeGenerationPrompt): Promise<IGeneratedCode> {
    // Simulate API delay
    await this.delay(1000);
    
    const workItem = prompt.workItem;
    const serviceName = this.sanitizeClassName(workItem.title);
    
    // Generate mock TypeScript service
    const serviceFile: IGeneratedFile = {
      path: `src/services/${serviceName}.ts`,
      content: this.generateServiceCode(serviceName, workItem),
      language: ProgrammingLanguage.TYPESCRIPT,
      type: FileType.SOURCE
    };
    
    // Generate mock test file
    const testFile: IGeneratedFile = {
      path: `src/services/${serviceName}.test.ts`,
      content: this.generateTestCode(serviceName, workItem),
      language: ProgrammingLanguage.TYPESCRIPT,
      type: FileType.TEST
    };
    
    return {
      files: [serviceFile],
      tests: [testFile],
      documentation: this.generateDocumentation(serviceName, workItem),
      dependencies: ['typescript', '@types/node'],
      buildInstructions: 'Run `npm run build` to compile TypeScript files'
    };
  }
  
  async validateGeneratedCode(code: string, language: string): Promise<IValidationResult> {
    // Simulate validation delay
    await this.delay(500);
    
    // Simple mock validation
    const issues: ICodeIssue[] = [];
    
    // Check for basic syntax issues
    if (!code.includes('export')) {
      issues.push({
        type: 'warning',
        message: 'No exports found in the code',
        line: 1,
        column: 1,
        severity: 'warning'
      });
    }
    
    return {
      isValid: issues.length === 0,
      issues,
      suggestions: issues.length > 0 ? ['Add proper exports to your code'] : [],
      score: issues.length === 0 ? 100 : 80
    };
  }
  
  async fixCodeIssues(code: string, issues: ICodeIssue[]): Promise<string> {
    // Simulate fix delay
    await this.delay(300);
    
    // Simple mock fix - just return the original code with a comment
    return `// Auto-fixed code\n${code}`;
  }
  
  private generateServiceCode(serviceName: string, workItem: any): string {
    return `/**
 * ${serviceName} - Generated from work item #${workItem.id}
 * ${workItem.description || 'Auto-generated service'}
 * 
 * This code was automatically generated by Redimento Code Generator
 */

export interface I${serviceName} {
  /**
   * Main method for ${serviceName}
   */
  execute(): Promise<void>;
  
  /**
   * Get status of the service
   */
  getStatus(): string;
}

export class ${serviceName} implements I${serviceName} {
  private status: string = 'initialized';
  
  constructor() {
    console.log('${serviceName} initialized');
  }
  
  /**
   * Execute the main functionality
   * Based on: ${workItem.title}
   */
  async execute(): Promise<void> {
    this.status = 'executing';
    
    try {
      // TODO: Implement the actual logic for: ${workItem.title}
      console.log('Executing ${serviceName}...');
      
      // Simulate some work
      await this.delay(100);
      
      this.status = 'completed';
      console.log('${serviceName} completed successfully');
    } catch (error) {
      this.status = 'error';
      console.error('Error in ${serviceName}:', error);
      throw error;
    }
  }
  
  /**
   * Get the current status of the service
   */
  getStatus(): string {
    return this.status;
  }
  
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

export default ${serviceName};
`;
  }
  
  private generateTestCode(serviceName: string, workItem: any): string {
    return `/**
 * Tests for ${serviceName}
 * Generated from work item #${workItem.id}
 */

import { ${serviceName} } from './${serviceName}';

describe('${serviceName}', () => {
  let service: ${serviceName};
  
  beforeEach(() => {
    service = new ${serviceName}();
  });
  
  it('should initialize correctly', () => {
    expect(service).toBeDefined();
    expect(service.getStatus()).toBe('initialized');
  });
  
  it('should execute successfully', async () => {
    await service.execute();
    expect(service.getStatus()).toBe('completed');
  });
  
  it('should handle errors gracefully', async () => {
    // Mock an error scenario
    jest.spyOn(console, 'log').mockImplementation(() => {
      throw new Error('Test error');
    });
    
    await expect(service.execute()).rejects.toThrow('Test error');
    expect(service.getStatus()).toBe('error');
  });
});
`;
  }
  
  private generateDocumentation(serviceName: string, workItem: any): string {
    return `# ${serviceName}

## Overview
This service was automatically generated from Azure DevOps work item #${workItem.id}.

**Title:** ${workItem.title}
**Description:** ${workItem.description || 'No description provided'}
**Type:** ${workItem.type}

## Usage

\`\`\`typescript
import { ${serviceName} } from './services/${serviceName}';

const service = new ${serviceName}();
await service.execute();
console.log(service.getStatus());
\`\`\`

## Methods

### execute()
Executes the main functionality of the service.

### getStatus()
Returns the current status of the service.

## Generated by
Redimento Code Generator - ${new Date().toISOString()}
`;
  }
  
  private sanitizeClassName(title: string): string {
    // Convert title to PascalCase class name
    return title
      .replace(/[^\w\s]/g, '') // Remove special characters
      .split(/\s+/) // Split by whitespace
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('')
      .replace(/^[0-9]/, 'Service$&') // Prefix with 'Service' if starts with number
      || 'GeneratedService'; // Fallback name
  }
  
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}